两个数据概念:
1. 字段定义 表头中的内容,用来表明一个字段的类型信息,与内容无关
2. 数据内容 填充的数据内容,用来给表头对应的字段赋值

!!!!重要!!!!!有效数据表:
A1格子必须填入**,表明是一个有效数据表
然后在下面开始定义表格字段,定义完成后再以**结束,表明表头定义完成,目前表头定义支持5部分内容.对应含义及功能在下面逐条介绍
1) 字段名
2) 类型
3) 导出
4) 内容描述
5) 检查规则
excel中第一行的剩余单元格内,可以继续写对应列字段的导出平台.#开头是任何平台都不导出的字段,剩余字符串中只要包含平台名称就会导出
excel中第一列的剩余单元格内,可以继续写对应行数据的导出平台,#开头是任何平台都不导出的数据,剩余字符串中只要包含此次导出平台名称就会导出

**版本限定支持多个合并,比如jp&bz,这样只有dev版本下才不会导出,配置不区分先后顺序
**多种平台配置之间建议使用'&'或者' '符号连接,以增强可读性.jp&dev,也可以配置dev jp,但是不强制使用连接符,直接配置成jpdev(devjp)也将生效

1. 字段名(xml中使用<var name="xxx"/>定义) -- 表达一个excel表中导出后有哪些字段
	命名规范:
		1) 支持纯英文\数字\下划线,不能以数字开头
		2) 首字母小写,每个单词之间使用下划线'_'分割开(仅建议,不强制)
		3) 不支持特殊符号,不要使用中文
	**示例: item_count	target_id
	**:命名不规范的字段将会被忽略,不导出对应字段所在列,比如已数值开头的字段或者使用出现了中文的字段

2. 类型(xml中使用<var name="xxx" type="xxx"/>定义) -- 表达该字段以何种方式存储数据,存储的是什么类型的数据.
	支持的类型包含以下三大类:
	单一类型
		基础类型
			int:整型
			float 浮点型(导表工具使用定点数存储,不用担心丢失精度)
			string 字符串型
			vector2\vector3\vector4 向量
			vec2\vec3\vec4 向量缩写
		自定义类型
			枚举类型,在xml文件中定义枚举名称\别名\值. 类型处填入枚举值即可,例如EBattleType
			对象类型,在xml文件中定义扩展的对象名称\字段等信息,在类型处填入对象类型名即可,例如ItemConsume
	列表类型
		任何单一类型名称后面加上'[]'表明该类型为一个列表类型
		例如:int[]\ vec2[]\ EBattleType[]\ ItemConsume[] 等
	**错误的字段类型将有提示配错文件的具体位置,并且不导出对应列的数据

3. 导出类型(xml中字段列添加属性标签  'out="xxx"' 来定义,可选) -- 对字段的导出限制
	导出端配置:
		在excel中的字段下的导出一行,配置导出类型.
		c\C表示仅客户端导出
		s\S表示仅服务器导出
		cs\sc\CS\SC表示客户端和服务器一起导出
		不填写默认cs,即客户端和服务器都需要导出

4. 内容描述和限(xml中在字段定义后添加一个 'append="xxx&xxx"' 属性来定义,可选)> -- 表达对字段下所填数据内容的修饰.比如指定哪个字段作为key值
	1) key值指定
		使用'key'可以手动指定该数据表的key值字段,TODO:如果不指定默认使用从左到右第一个有效列字段作为key值
	2) 默认值指定
		使用default=xxx来为该列的所有配置指定一个默认值,
		例如:
			int列配置default=128,该列的所有未填数据的格子,都将自动填充数值为128;
			int[]列配置default=0,0,则该列所有未填入数据的格子都将是{0,0};
			int[]default=0,则该列所有未填入数据的格子都是{0}.
		还可以直接填入default=nil或者default=null.(nil和null不区分大小写),指定不填入的值为空值
		如果不指定nil或者null
			单一类型默认值:
				int\float默认值为0, vector2默认值(0,0), vector3默认值(0,0,0), vector4默认值(0,0,0,0),string默认值"",自定义枚举类型值为0,自定义object为null
			列表类型默认值: 对应单一类型的长度为0的数组,不是null.
	3) 手动指定分割符
		使用sep=x表明x为指定分割符,分割符是将字符串处理成正确类型时所需要的字符,后面根据嵌套层级可以指定多级分隔符,分隔符只支持一个任意字符

			1>不同类型的默认分隔符: 不手动指定分割符时,将使用默认分隔符处理数据,如果数据配置错误,将无法解析
				单一类型:
					vector类型,使用','分割不同的数值,不填入值为0,比如 vec2类型 内容配置为'1'或者'1,',转完结果为(1,0); 内容配置',1',转完结果为(0,1);配置','转换结果为(0,0)
					为可读性良好,建议写全,即使数值是0
					xml自定义对象类型的字段之间使用分割符'_'来分割,比如xml中定义了消耗类
					<obj type="Consume">
						<var name="item_id" type="int" out="cs"/>
						<var name="use_count" type="int"/>
					</obj>
					内容配置时使用:10025_25
				列表类型:
					字符串列表,默认分割符为'|',其余所有的列表类型默认分隔符均为','
					当配置vector[]时,可以使用小括号将数据分组,例如'(1,0),(0,0)',则会生成两个向量(1,0)和(0,0),如果配置成1,0,0,0,则会分割出错,可能会解析出异常的数据

			2> 手动指定分割符的作用,如果用不到可以不配置
				主要是为了excel的可读性,分隔符可以指定为任何单一字符,比如   '*'   '和' 等等
				配置时使用: 'sep=和',内容配置 '1,0和0,0',(这里因为没有重复的分割符,不会导致歧义,所以不再需要使用括号分组)

				比如上面xml中自定义了一个消耗类型(Consume),包含两个字段 item_id,use_count
				那配置时指定分割符为*: 'sep=*',内容就可以配置为'10025*25',来表达一次消耗为25个id为10025的道具

				再骚一点,在xml定义类的字段时,可以通过添加一个 'index="xxx"'属性来为字段指定内容填充索引,如果不指定,则默认索引自增
				<obj type="Consume">
					<var name="item_id" type="int" out="cs" index="2"/>
					<var name="use_count" type="int" index="1"/>
				</obj>
				将use_count的index设置为1, item_id的index设置为2,并且在配置内容时手动指定分割符'sep=个',则在配置内可以直接写入'25个10025'
				TODO:后面根据情况是否扩展别名机制,可以直接让填入的内容为'25个测试道具',其中'测试道具'为具体的道具名称
				**手动指定的分割符同时对default内容生效,请保证default内容和手填写内容格式一致

			3> 多级分隔符
				目前分割符有三个等级,从最外层到最内层分别是 :   '|'   ','   '_'
				'_'为自定义对象(xml中定义obj)对应数据的默认分割符, ','为常见的分割符,  '|'只为字符串数组的分割符

				当配置数据嵌套多层时,可以使用sep=xxx来指定3个分割符(有几级就需要为sep指定几个字符),第一个分割符表示最上级分隔符
				比如我想配置一个上面xml中定义的Consume[]
				指定 'sep=和个' ,内容填写时就可以填入'25个10025和30个10026'
				指定 'sep=,个' ,内容填写时就可以填入'25个10025,30个10026'
				第一个分隔符表达第一层数据的切割符号,'个'表示第二层自定义类型的数据切割,配合小括号分组(见特性4>),可以实现无限嵌套
				但是仍然不建议无限嵌套去做,建议最多搞三层,否则将会有一帮人因为可读性问题骂你

			4> 分组
				支持嵌套,使用()进行分组就行了
				比如我在Consume基础之上又定义了一层obj,其中EnumType是一个枚举类型定义 EnumType.Test1=1, EnumType.Test2=2....
				<obj type="UseObj">
						<var name="obj" type="Consume" out="cs" index="1" />
						<var name="enum" type="EnumType" index="2" />
						<var name="listint" type="int[]" index ="3" />
				</obj>
				有一个UseObj类型的字段,则可以填入(10_20)_Long_(1,2,3),其中'_'为类型默认分隔符, (1,2,3)中的','为int数组默认分隔符
5. 内置检查规则
	1> 数据引用定义 'ref=xxx.xxx'
		让数据间产生强依赖,保证一个基础数据的使用处必须填入存在的基础数据,如果基础数据不存在,会给出对应位置和提示,并且不会再导出该行数据
		比如在自定义类型Consume的item_id字段,很明显就是必须要依赖item表中的一个已经存在的道具id
		在xml中添加 'ref="Item.id"'属性
		在excel中的附加内容行使用&连接多个附加定义 'ref=Item.id'
		** 其中Item是道具表表名,id是道具表的字段名

		<obj type="Consume">
				<var name="item_id" type="int" out="cs" ref="Item.id"/>
				<var name="use_count" type="int" index="1"/>
		</obj>

		效果即为: 一开始item表(配置A)中有10025的道具,在配置B了一个升级消耗为 10025*25,突然有一天管Item的兄弟把道具表的id修改了,或者10025道具因为迭代不再需要使用了.而在配置B处的升级消耗的内容仍然配置着10025*25,在导表时就提示, '配置A中已经不存在id=10025,但是配置B的路径.B的字段名仍然在使用该数据'
		结合到距离
		使用Consume[]做了一个测试,可以看到log的格式为

		'Error: UseItem类型中不存在upgrade=Channel.Data.DataObject[2]={Consume[item_id=100,use_count=1000],Consume[item_id=2000,use_count=2000]}的数据,但是却想在=>F:\FWK\BuildTool\Config\Test\RefTest.xlsx 第10行.upgradeRef中使用'

		完整的例子:  比如一个vector2[]类型的字段,需要保证后面填入的内容都在ValidPos表中的value项中出现过
		default=(0,0)+(1,1)&sep=+,&ref=ValidPos.value
	2> 游戏资源路径检查 定义 'res=asset/img/icon/' TODO: res后面的内容为资源前缀路径
		可以检查配置路径的文件是否在工程中存在,如果不存在将会提示

	** xml中需要使用资源检查功能,需要定义'res="path"'属性,但基本上不会在xml中进行定义,否则组织数据时会变得特别长,虽然支持但是实际使用意义有限
	** 多个检查规则之间使用&号连接

6. 添加自定义检查规则的方法:
	1>  创建一个Rule,以内置ref检查规则为例
			Rule checkReference = new Rule("ref", InnerCheck_CheckReferenceValid.Check);
		其中'ref'称为规则名称, 后面的是规则检查回调.Action<List<Rule.RuleInfo>>
		规则创建好后,调用
			Checker.AddRule(checkReference, CheckStage.ParseOver)
		第二个参数为检查的时机,如果是需要检查定义的,可以在CheckStage.CompileOver(编译完成时)执行,如果是要检查内容,则需要在ParseOver时执行
	2> 在需要使用该规则的excel的'检查规则'一列,填入对应的规则名称,以及所需要的信息,excel的填入格式为 'ref=Item.id'.则在对应时机时,调用回调时,将会把标记了该规则的字段以及该字段所需要使用的信息一同组织到RuleInfo中,等待在规则执行时调用返回.
		然后可以根据所需参数,以及lookup的所有数据缓存进行检查\定义\提示等等功能.


TODO: 常量表的支持,需要支持横向配置不同类型
TODO: 数据类型支持常量
TODO: 别名机制
TODO: 支持使用lua脚本添加rule
TODO: DevJava, ReleaseJava, ReleaseLua版本的代码导出











